
### 一、切片本质与结构
1. **引用类型结构体**  
   - 切片是数组的**动态引用**，底层为结构体：  
     ```go
     type slice struct {
         array unsafe.Pointer // 指向底层数组
         len   int            // 当前元素数量（可用长度）
         cap   int            // 底层数组总容量
     }
     ``` 
   - 值拷贝传递（复制结构体，但共享底层数组）。

2. **动态可变**  
   - 长度与容量可变，支持动态扩容（区别于静态数组）。

3. **空切片判定**  
   - `slice == nil` 时，`len` 和 `cap` 均为 `0`（未初始化状态）。

---

### 二、切片创建方式
| **方法**         | **示例**                          | **适用场景**               |
|------------------|-----------------------------------|--------------------------|
| 直接声明         | `var s []int`                     | 暂不初始化                |
| 字面量初始化     | `s := []int{1, 2, 3}`             | 已知初始元素              |
| `make` 预分配    | `s := make([]int, 3, 10)`         | 需指定初始长度和容量      |

---

### 三、切片基本操作
1. **截取（左闭右开）**  
   ```go
   arr := [5]int{0, 1, 2, 3, 4}
   s1 := arr[1:3] // [1, 2]（len=2, cap=4）
   ```

2. **追加（`append`）**  
   - 返回新切片（可能触发扩容）：  
     ```go
     s := []int{1, 2}
     s = append(s, 3)       // 单元素追加 → [1, 2, 3]
     s = append(s, s1...)   // 追加另一切片
     ```

3. **复制（`copy`）**  
   - 按较小 `len` 复制，允许重叠：  
     ```go
     s1 := []int{0, 1, 2}
     s2 := []int{3, 4, 5, 6}
     copy(s2, s1) // s2 → [0, 1, 2, 6]
     ```

---

### 四、扩容规则（Go 1.18+）
触发条件：`append` 时 `len > cap`。扩容策略如下：  
| **场景**                  | **计算规则**                     | **示例（旧容量=200）** |
|---------------------------|----------------------------------|------------------------|
| 所需容量 > 2倍旧容量      | 新容量 = 所需容量               | 需500 → 新cap=500     |
| 旧容量 < 256              | 新容量 = 2倍旧容量               | 200 → 新cap=400       |
| 旧容量 ≥ 256              | 新容量 = 旧容量 + (旧容量 + 3×256)/4 | 1000 → 新cap ≈ 1250   |

> 注：最终容量会根据内存对齐微调。

---

### 五、高级特性与陷阱
1. **共享底层数组**  
   - 多个切片可能共享同一数组，修改一处可能影响其他切片：  
     ```go
     arr := []int{1, 2, 3}
     s1 := arr[:2]  // [1, 2]
     s1[0] = 9      // arr → [9, 2, 3]
     ```

2. **函数传递行为**  
   - 函数内修改元素会影响原切片（共享数组），但追加可能触发扩容导致分离。

3. **性能优化**  
   - **预分配**：`make([]int, 0, 1000)` 避免高频扩容。  
   - **复用内存**：对大切片重置后复用（`s = s[:0]`）。  
   - **批量追加**：`append(s, elem1, elem2, ...)` 减少扩容次数。

---

### 六、关键总结
- **容量是性能关键**：频繁扩容（尤其大切片）会引发数据复制与GC压力。  
- **共享需谨慎**：跨切片修改前确认底层数组是否分离（`cap` 变化或显式 `copy`）。  
- **最佳实践**：  
  ```go
  // 预分配 + 批量追加
  s := make([]int, 0, 100)
  s = append(s, batchData...)
  ```

> 完整实现可参考 `runtime/slice.go` 中的 `growslice` 函数。